### JAVA设计模式
#### 软件架构设计七大原则
* 开闭原则
  * 开闭原则（Open-ClosedPrinciple,OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。
* 依赖倒置原则
  * 依赖倒置原则（DependenceInversionPrinciple,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。
* 单一职责原则
  * 单一职责（SimpleResponsibilityPinciple，SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个Class负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个Class存在两个导致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个Class来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个Class/Interface/Method只负责一项职责。
* 接口隔离原则
  * 接口隔离原则（InterfaceSegregationPrinciple,ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时应当注意一下几点：1、一个类对一类的依赖应该建立在最小的接口之上。2、建立单一接口，不要建立庞大臃肿的接口。3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解是非常重要的。
* 迪米特法则
  * 迪米特原则（LawofDemeterLoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（LeastKnowledgePrinciple,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。现在来设计一个权限系统，Boss需要查看目前发布到线上的课程数量。这时候，Boss要找到TeamLeader去进行统计，TeamLeader再把统计结果告诉Boss。
* 里氏替换原则
  * 里氏替换原则（LiskovSubstitutionPrinciple,LSP）是指如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下：引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。2、子类中可以增加自己特有的方法。3、当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。
  使用里氏替换原则有以下优点：1、约束继承泛滥，开闭原则的一种体现。2、加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。
* 合成复用原则
  * 合成复用原则（Composite/AggregateReusePrinciple,CARP）是指尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循OOP模型。
#### Spring中用到的设计模式
* 工厂模式BeanFactory
* 装饰器模式BeanWrapper
* 代理模式AopProxy单例模式
* ApplicationContext
* 委派模式DispatcherServlet
* 策略模式HandlerMapping
* 适配器模式HandlerApdapter
* 模板方法模式JdbcTemplate
* 观察者模式ContextLoaderListener

#### 工厂模式
单例模式的应用场景
单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并 提供一个全局访问点。单例模式是创建型模式。
* 简单工厂模式
简单工厂模式（SimpleFactoryPattern）是指由一个工厂对象决定创建出哪一种产品类的实例。
* 工厂方法模式
工厂方法模式（FatoryMethodPattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。
* 抽象工厂模式
抽象工厂模式（AbastractFactoryPattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。
#### 单例模式
* 饿汉式单例
饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题。 优点:没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点:类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，
* 懒汉式单例
懒汉式单例的特点是:被外部类调用的时候内部类才会加载
* 注册式单例

注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标 识获取实例。注册式单例有两种写法:一种为容器缓存，一种为枚举登记。
* threadlocal式单例，伪单例模式，线程内单例（保证同一个线程内是单例的）
ThreadLocal 不能保证其 创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全。
ThreadLocal 将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象
#### 原型模式
原型模式(Prototype Pattern)是指原型实例指定创建对象的种类，并且通过拷贝这些 原型创建新的对象。
原型模式主要适用于以下场景:
1、类初始化消耗资源较多。
2、new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等)
3、构造函数比较复杂。
4、循环体中生产大量对象时。

#### 代理模式
* 静态代理
    动态代理和静态对比基本思路是一致的，只不过动态代理功能更加强大，随着业务的扩 展适应性更强。
* 动态代理
    * JDK动态代理
    * CGLib动态代理
    CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象 实现的动态代理
    CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机 制，它的原理简单来说就是:为代理类和被代理类各生成一个 Class，这个 Class 会为代 理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass 就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK
* 动态代理通过反射调用高。
    CGLib 和 JDK 动态代理对比
    1.JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。
    2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。
    3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。
* 静态代理和动态的本质区别
  * 1、静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步 新增，违背开闭原则。 
  * 2、动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开 闭原则。 
  * 3、若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成， 无需修改代理类的代码。    
* 代理模式的优缺点
  * 1、代理模式能将代理对象与真实被调用的目标对象分离。 
  * 2、一定程度上降低了系统的耦合度，扩展性好。 
  * 3、可以起到保护目标对象的作用。 
  * 4、可以对目标对象的功能增强。 
  缺点的:
  * 1、代理模式会造成系统设计中类的数量增加。 
  * 2、在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。 
  * 3、增加了系统的复杂度。
 #### 委派模式
 委派模式(Delegate Pattern)的基本作用就是负责任务的调 度和分配任务，跟代理模式很像，可以看做是一种特殊情况下 的静态代理的全权代理，但是代理模式注重过程，而委派模式 注重结果。
 #### 策略模式
 策略模式(Strategy Pattern)是指定义了算法家族、分别封 装起来，让它们之间可以互相替换，此模式让算法的变化不会 影响到使用算法的用户。

 #### 模版模式
 #### 适配器模式
 #### 装饰器模式
 #### 观察者模式
 